package generate

import (
	"bytes"
	"slices"
	"strings"

	"github.com/Instantan/web/internal/openapi"
)

const typescriptFetchClient = `
type ClientOptions = {
	url?: string
	beforeRequest?: (api: {
		method: any,
		path: any,
		params: {
			path: any,
			header: any,
			body: any,
			cookie: any,
			query: any
		}
	}) => void,
	afterRequest?: (response: any) => void
}

function createClient(options?: ClientOptions): Api {
	const url = options?.url ? options.url : ''
	return (async (api: any) => {
		const query = new URLSearchParams()
		const queryObj = api?.params?.query || {}
		Object.keys(queryObj).forEach(name => query.set(name, queryObj[name]))
		const queryString = (query.size > 0 ? '?' + query.toString() : '')
		const pathParams = api?.params?.path || {}
		const path = api.path.replace(/{(\w+)}/g, (_, key) => 
			pathParams[key] !== undefined ? pathParams[key] : '{' + key + '}'
		)
		const resp = await fetch(url + path + queryString, {
			method: api.method,
			body: api?.params?.body,
		})
		return {
			status: resp.status,
			body: await resp.json()
		}
	}) as Api
}

export {
	createClient
}
`

func GenerateTypescriptModels(api openapi.OpenAPI) []byte {
	b := bytes.NewBuffer([]byte{})
	must(b.WriteString("// Code generated by web DO NOT EDIT\n\n"))

	if api.Info.Title != "" {
		must(b.WriteString("/**\n *  " + api.Info.Title + " " + api.Info.Version + "\n */\n"))
	}
	if api.Paths.Len() > 0 {
		must(b.WriteString("interface Api {\n"))
		for route, path := range api.Paths.Iterate() {
			writeTypescriptFunctionInterfaceToBuffer(b, route, path)
		}
		must(b.WriteString("}"))
		must(b.WriteString("\n"))
	}

	for name, schema := range api.Components.Schemas {
		must(b.WriteString("\n"))
		writeTypescriptModelToBuffer(b, name, schema)
	}

	must(b.WriteString(typescriptFetchClient))
	return b.Bytes()
}

func writeTypescriptFunctionInterfaceToBuffer(b *bytes.Buffer, route string, path openapi.PathItem) {
	for method, operation := range path.IterateOperations() {
		writeIntentToBuffer(b, 1)
		must(b.WriteString("(api: {\n"))
		{
			// method
			writeIntentToBuffer(b, 2)
			must(b.WriteString("method: '"))
			must(b.WriteString(method))
			must(b.WriteString("',\n"))
		}
		{
			// path
			writeIntentToBuffer(b, 2)
			must(b.WriteString("path: '"))
			must(b.WriteString(route))
			must(b.WriteString("',\n"))
		}
		{
			// params
			querySchema := operation.QuerySchema()
			cookieSchema := operation.CookieSchema()
			pathSchema := operation.PathSchema()
			headerSchema := operation.HeaderSchema()

			writeIntentToBuffer(b, 2)
			must(b.WriteString("params: {\n"))

			if len(pathSchema.Properties) > 0 {
				writeIntentToBuffer(b, 3)
				must(b.WriteString("path: "))
				writeSchemaToBuffer(b, pathSchema, 3)
				must(b.WriteString(",\n"))
			}
			if len(querySchema.Properties) > 0 {
				writeIntentToBuffer(b, 3)
				must(b.WriteString("query: "))
				writeSchemaToBuffer(b, querySchema, 3)
				must(b.WriteString(",\n"))
			}
			if len(cookieSchema.Properties) > 0 {
				writeIntentToBuffer(b, 3)
				must(b.WriteString("cookie: "))
				writeSchemaToBuffer(b, cookieSchema, 3)
				must(b.WriteString(",\n"))
			}
			{
				writeIntentToBuffer(b, 3)
				if len(headerSchema.Properties) > 0 {
					must(b.WriteString("header: Record<string, string>"))
					must(b.WriteString(" & "))
					writeSchemaToBuffer(b, headerSchema, 3)
				} else {
					must(b.WriteString("header?: Record<string, string>"))
				}
				must(b.WriteString(",\n"))
			}
			if operation.RequestBody != nil {
				writeIntentToBuffer(b, 3)
				if !operation.RequestBody.Required {
					must(b.WriteString("body: "))
				} else {
					must(b.WriteString("body?: "))
				}
				i := 0
				for _, content := range operation.RequestBody.Content {
					if i > 0 {
						must(b.WriteString(" | "))
					}
					writeSchemaToBuffer(b, content.Schema, 1)
					i++
				}
				must(b.WriteString(", "))
			}
			writeIntentToBuffer(b, 2)
			must(b.WriteString("}\n"))
		}
		{
			// Response
			writeIntentToBuffer(b, 1)
			must(b.WriteString("}): "))
			must(b.WriteString("Promise<"))
			c := 0
			for code, response := range operation.Responses.Iterate() {
				if c != 0 {
					must(b.WriteString(" | "))
				}
				c++
				must(b.WriteString("{\n"))
				writeIntentToBuffer(b, 2)
				must(b.WriteString("status: "))
				must(b.WriteString(code))
				must(b.WriteString(",\n"))
				writeIntentToBuffer(b, 2)
				must(b.WriteString("body: "))
				i := 0
				for _, mediatype := range response.Content {
					if i != 0 {
						must(b.WriteString(" | "))
					}
					i++
					writeSchemaToBuffer(b, mediatype.Schema, 4)
				}
				must(b.WriteString("\n"))
				writeIntentToBuffer(b, 1)
				must(b.WriteString("}"))
			}
			must(b.WriteString(">;\n"))
		}
	}
}

func writeTypescriptModelToBuffer(b *bytes.Buffer, name string, schema openapi.Schema) {
	must(b.WriteString("type "))
	must(b.WriteString(name + " = "))
	writeSchemaToBuffer(b, schema, 0)
	must(b.WriteString("\n"))
}

func writeIntentToBuffer(b *bytes.Buffer, indentLevel int) {
	must(b.WriteString(strings.Repeat("  ", indentLevel)))
}

func writeSchemaToBuffer(b *bytes.Buffer, schema openapi.Schema, indentLevel int) {
	if schema.Ref != "" {
		must(b.WriteString(extractSchemaName(schema.Ref)))
		return
	}

	indent := strings.Repeat("  ", indentLevel)

	switch schema.Type {
	case "object":
		if len(schema.Properties) > 0 {
			must(b.WriteString("{\n"))
			for propName, propSchema := range schema.Properties {
				must(b.WriteString(indent + "  " + propName))
				// Check if the property is optional
				if !slices.Contains(schema.Required, propName) {
					must(b.WriteString("?"))
				}
				must(b.WriteString(": "))
				writeSchemaToBuffer(b, *propSchema, indentLevel+1)
				must(b.WriteString(";\n"))
			}
			b.WriteString(indent + "}")
		} else {
			must(b.WriteString("never"))
		}
	case "array":
		writeSchemaToBuffer(b, *schema.Items, indentLevel)
		must(b.WriteString("[]"))
	case "string":
		must(b.WriteString("string"))
	case "number", "integer":
		must(b.WriteString("number"))
	case "boolean":
		must(b.WriteString("boolean"))
	case "null":
		must(b.WriteString("null"))
	default:
		must(b.WriteString("any"))
	}
}
